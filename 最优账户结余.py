# coding=utf-8
# 例如，爱丽丝为比尔的午餐支付了 10 美元。后来克里斯给爱丽丝 5 美元搭出租车。
# 我们可以假设每笔交易为一个三元组(X,Y,Z)，这意味着第 X 个人借给第 Y 个人 Z 美元。
# 假设 Alice，Bill 和 Chris 是第0，1，2  个人（0，1，2是他们的ID），
# 他们之间的交易可以表示为[ [ 0，1，10 ]，[ 2，0，5 ] ]。
# 给定一组人之间的交易清单，返回结算所需的最低交易数量
# 输入 [[0,1,10], [1,0,1], [1,2,5], [2,0,5]]
# 输出 1
# 样例解释
# 第0个人借给第1个人10美元
# 第1个人借给第0个人1美元
# 第1个人借给第2个人5美元
# 第2个人借给第0个人5美元
# 只需要1笔交易，第1个人还给第0个人4美元债务就还清了。
# 对于预处理完收支情况的一个数组[ 2 , 3 , -2 , -3 ](用正数表示收入，负数表示支出)，
# 显而易见答案是2 （2 → -2 , 3 → -3  ），但是还有一种不是最优的答案3（3 → -2 , 1 → -3 , 2 → -2）。
# 那么我们就能发现，最优答案是2个子问题([2,-2],[3,-3])的最优解的和。
# 我们可以用集合枚举所有的子集，找到每个子集的最优解从而解得总问题的最优解。
# 在这里我们可以把一个集合的子集定义为一个只有 0,1 的向量，
# 比如一个有3个元素的集合，他们的子集分别是000(空集),001,010,100,011,110,101,111(全集)，
# '1'代表这个子集里有这个元素，'0'代表这个子集里没有这个元素。
# 再利用一个1~n循环来判断这个子集里有哪些元素，如101代表这个子集里有第1个和第3个元素。
import sys
def minTransfers(transactions):
    debt = {}
    # 预处理收支情况
    for t in transactions:
        debt[t[0]] = debt.get(t[0],0)-t[2]
        debt[t[1]] = debt.get(t[1],0)+t[2]
    # 出去收支平衡的人
    account = [0]* len(debt)
    length = 0
    for v in debt.values():
        if v != 0:
            account[length] = v
            length += 1
    if length == 0:
        return 0
    # account =[2,3,-2,-3]
    # length=4
    dp = [sys.maxint/2]*(1<<length)
    print account
    # 枚举每一个子集
    for i in range(1,len(dp)):
        sum = 0
        count = 0
        for j in range(length):
            # 这个子集里有第j个人
            if (1 << j & i) != 0:
                # 加上第j个人的收支情况
                sum += account[j]
                count += 1
        # 如果这个子集收支平衡，那么它是一个子问题
        if sum ==0 :
            # 这个子问题需要的最大交易数
            dp[i] = count -1
            # 枚举这个子问题的子集
            for j in range(1,i):
                #i子集包含j子集 ,例如 i->1010,j->  10
                if (i & j) == j:
                    # 求这个子问题的最优解
                    dp[i] = min(dp[i],dp[j] + dp[i-j])
    print dp
    return dp[-1]
print minTransfers([[0,2,2],[1,3,3]])